### 싱글톤 패턴 개요

싱글톤(Singleton) 패턴은 **어떤 클래스의 인스턴스를 오직 하나만 생성**하도록 제한하고, 그 인스턴스에 대한 **전역적인 접근점을 제공**하는 생성 패턴입니다. 주로 애플리케이션 전체에서 공유되어야 하는 설정 정보나 **로그 객체, DB 연결, 캐시, 스레드풀** 같은 리소스를 관리할 때 사용됩니다​. 자바 코어 라이브러리에서도 `Runtime.getRuntime()`이나 `Desktop.getDesktop()` 등이 싱글톤 패턴을 활용한 예입니다.

싱글톤 클래스를 구현하려면 **(1) 생성자를 private으로 감춰 외부에서 `new`로 생성하지 못하게 하고**, **(2) 클래스 내부에 자신의 유일한 인스턴스를 가리키는 static 변수를 유지**하며, **(3) 그 인스턴스를 반환하는 public static 메서드**(주로 `getInstance()` 이름)를 제공합니다​. 기본 구조는 다음과 같습니다:

``` java
public class Singleton {     // 유일한 인스턴스를 저장할 정적 변수     
	
	private static Singleton instance;     // private 생성자 -> 외부에서 new 불가
	
	private Singleton() {}     // 인스턴스에 대한 전역 접근 메서드     
	
	public static Singleton getInstance() {         
		if (instance == null) {             
			instance = new Singleton();         
		}         
		
		return instance;     
	} 
}
```

위 예시는 **지연 초기화(Lazy Initialization)** 방식으로 `getInstance()`가 처음 호출될 때 인스턴스를 생성합니다. 그러나 이 구현은 **단일 스레드 환경에서는 문제없지만, 멀티스레드 환경에서는 문제**가 있습니다. 예를 들어 두 개의 스레드가 동시에 `if (instance == null)` 검사를 통과하면 각각 새로운 `Singleton()`을 호출하여 **두 개의 인스턴스가 생성**될 수 있습니다. 이러한 조건 경쟁(race condition)이 발생하면 싱글톤 패턴의 “단일 인스턴스” 원칙이 깨지게 됩니다. 따라서 멀티스레드 환경에서 안전한 싱글톤을 구현하기 위한 여러 가지 방법들이 고안되었습니다.

### 멀티스레드 환경에서의 싱글톤 구현 방법들

싱글톤을 멀티스레드 환경에서 안전하게 구현하기 위해서는 동시성 제어가 필요합니다. 대표적인 구현 방법으로 **동기화(synchronized)**를 사용하는 방법, **이른 초기화(Eager Initialization)**, **Double-Checked Locking(이중 검증 락)**, **정적 내부 클래스(Initialization-on-demand holder)** 방식이 있습니다. 각 방법별 구현과 특징을 살펴보겠습니다.

### 1. 동기화 메서드를 사용하는 방법

가장 간단한 스레드 안전 싱글톤 구현은 `getInstance()` 메서드에 동기화를 거는 것입니다. 이렇게 하면 여러 스레드가 동시에 `getInstance()`를 호출해도 한 번에 한 스레드만 메서드 내부를 실행하므로 인스턴스 중복 생성이 막아집니다. 구현은 다음과 같습니다:

``` java 
public class SynchronizedSingleton {     
	private static SynchronizedSingleton instance;     
	
	private SynchronizedSingleton() {}     
	
	public static synchronized SynchronizedSingleton getInstance() {         
		if (instance == null) {             
			instance = new SynchronizedSingleton();         
		}         
		
		return instance;     
	} 
}
```


**장점:** 구현이 간단하고 직관적이며, 동기화로 인해 멀티스레드 환경에서도 안전하게 하나의 인스턴스만 생성됩니다.

**단점:** `getInstance()`에 synchronized가 붙으면 **호출 때마다 잠금 오버헤드**가 발생하므로 성능이 저하될 수 있습니다. 사실 인스턴스가 한 번 생성되고 나면 굳이 매 호출마다 동기화할 필요는 없지만, 이 구현에서는 이후 호출들도 계속 동기화의 성능 비용을 지불하게 됩니다​. 최근 자바에서는 동기화의 성능이 개선되어 큰 문제가 없다는 견해도 있지만​​, 매우 빈번한 호출이 이루어지는 상황이라면 불필요한 오버헤드를 줄일 다른 방법을 고려할 수 있습니다.

### 2. 이른 초기화 (Eager Initialization) 방법

이른 초기화는 싱글톤 인스턴스를 애플리케이션 시작 시점에 **클래스 로딩과 동시에 미리 만들어 두는 방법**입니다. 인스턴스를 미리 만들어두기 때문에 **별도의 동기화 없이도 멀티스레드에 안전**하며 구현이 간결합니다. 예시는 다음과 같습니다:

``` java
public class EagerSingleton {     // 클래스가 로딩될 때 인스턴스를 즉시 생성
	private static final EagerSingleton INSTANCE = new EagerSingleton();
	
	private EagerSingleton() {}     
	
	public static EagerSingleton getInstance() {         
		return INSTANCE;     
	} 
}
```

이 코드는 JVM이 `EagerSingleton` 클래스를 로딩할 때 static 변수 `INSTANCE`를 초기화하면서 **한 번만 인스턴스를 생성**합니다. 자바 클래스 로딩은 **한 클래스당 한 번만 발생하고, 그 과정은 스레드에 안전(Thread-safe)**하기 때문에 별도의 동기화가 필요 없습니다. 따라서 Eager 방식은 구현이 단순하고 멀티스레드 문제 없이 사용할 수 있습니다.

**장점:** 구현이 쉽고 확실하게 한 개의 인스턴스만 생성됨이 보장됩니다. 또한 `getInstance()` 호출 시 이미 만들어진 객체를 반환하므로 **접근 속도가 빠르고**, 동기화 오버헤드가 없습니다.

**단점:** **지연 로딩이 불가능**하다는 점입니다. 즉, 실제 이 싱글톤이 필요 없더라도 애플리케이션 시작 시 무조건 생성되므로 **불필요한 리소스 사용**이 있을 수 있습니다. 특히 싱글톤 객체가 내부적으로 **무거운 자원(DB 연결, 대용량 메모리)** 등을 가지고 있거나, 사용되지 않을 가능성이 있는 경우에는 이른 초기화는 비효율적일 수 있습니다. 또한 이 방식은 내부에서 예외 처리를 할 수 없다는 단점도 있습니다 (필요하다면 정적 블록 초기화 기법으로 예외 처리를 추가할 수는 있습니다).

> **참고:** Eager 방식의 변형으로 **정적 블록(static block) 초기화** 방법도 있습니다. 이 역시 클래스 로딩 시점에 인스턴스를 생성하지만, 정적 초기화 블록 안에서 예외 처리를 할 수 있다는 점이 다릅니다​.​ 그러나 **Eager 초기화와 static 블록 초기화 모두 인스턴스를 필요 전에 만들어 놓는다는 점에서 비효율적일 수 있으며**, 일반적으로 권장되는 방법은 아닙니다.

### 3. Double-Checked Locking (이중 체크 락) 방법

Double-Checked Locking(두 번 검사하는 락 기법)은 위 동기화 방법의 성능 저하 문제를 개선하기 위한 패턴입니다. 아이디어는 **인스턴스가 생성된 이후에는 synchronized를 피하고**, 초기 생성 시에만 동기화를 하겠다는 것입니다. 구현은 다음과 같습니다:

``` java
public class DclSingleton {     // volatile로 선언하여 가시성 및 순서 보장     
	private static volatile DclSingleton instance;     
	
	private DclSingleton() {}     
	
	public static DclSingleton getInstance() {         
		if (instance == null) {                      // 첫 번째 체크 (락 없이)
			synchronized (DclSingleton.class) {                 
				if (instance == null) {              // 두 번째 체크 (락 안에서)
					instance = new DclSingleton();                 
				}             
			}         
		}         
		
		return instance;     
	} 
}
```

이중 체크를 통해 **인스턴스가 이미 생성된 이후에는 곧바로 반환**하므로, 초기화 이후의 호출에 대해서는 동기화 비용이 들지 않습니다. 반면 아직 생성되지 않은 시점에는 내부의 `synchronized` 블록에서 한 번 더 null 여부를 확인하여 최초 한 번만 생성 로직을 수행하게 됩니다. 이렇게 하면 `getInstance()`를 처음 호출하는 몇 스레드 사이에는 동기화가 일어날 수 있지만, **그 이후로는 동기화 없이 빠르게 반환**하므로 성능상 이점이 있습니다.

**중요 구현 포인트: `volatile` 키워드** – 위 코드에서 `instance` 변수를 `volatile`로 선언한 것이 핵심입니다. `volatile`은 한 스레드에서 발생한 객체 생성의 **메모리상 변화가 다른 스레드들에게 바로 보이도록 보장**하며, 또한 초기화 이전에 참조를 다른 스레드가 보는 일을 막기 위해 **명령어 reordering(재정렬)을 방지**합니다. 만약 `volatile`이 없으면, JIT 컴파일러나 CPU의 최적화에 의해 **`instance = new DclSingleton();` 과정이 재정렬**되어 인스턴스의 생성자 완료 전에 `instance` 참조를 할당하는 상황이 발생할 수 있습니다. 그럴 경우 다른 스레드가 `instance`가 완전히 생성되지 않았는데도 non-null인 참조를 보게 되어 **불완전한 객체에 접근하는 버그**가 생길 수 있습니다​. 실제로 자바 1.5 이전에는 이 문제로 double-checked locking 패턴이 깨진다고 알려졌었습니다. Java Memory Model이 개선된 **1.5 이후에도 `volatile` 없이 double-check를 구현하면 여전히 문제가 될 수 있기 때문에**, 반드시 `volatile`이 필요합니다. Java 5 이상에서는 `volatile`을 올바로 사용하면 double-checked locking이 안전하게 동작하며, 이는 JSR-133(JMM) 스펙에서도 명시된 사항입니다​.

**장점:** Lazy 초기화이므로 필요한 시점까지 객체 생성을 미루며, 한번 생성된 이후에는 동기화 비용 없이 인스턴스를 획득할 수 있어 **성능 효율이 높습니다**. 특히 `getInstance()`가 빈번히 호출되는 상황이라면 synchronized 방법보다 유리할 수 있습니다.

**단점:** 구현이 복잡하며 미세한 실수에도 오류가 발생하기 쉽습니다. `volatile` 선언을 빼먹거나 잘못 구현하면 오히려 심각한 버그를 초래할 수 있고, 언어 및 메모리 모델에 대한 이해가 필요합니다. 또한 최근 JVM에서는 uncontended 상태의 synchronized 비용이 많이 최적화되었기 때문에​ 단순한 synchronized 방법과 큰 성능 차이가 없다는 지적도 있습니다. 복잡도를 감수할 만큼의 이점이 있는지는 상황에 따라 판단해야 합니다.

### 4. 정적 내부 클래스 (Initialization-on-demand Holder) 방법

정적 내부 클래스 방식을 이용한 싱글톤 구현은 **Lazy 초기화와 멀티스레드 안전성을 가장 손쉽게 달성**하는 방법으로 널리 알려져 있습니다. 이를 **Bill Pugh 싱글톤 구현 방식**이라고 부르기도 하는데, double-checked locking이 자바 5 이전 메모리 모델에서 문제가 있었을 때 이를 대체하기 위해 고안되었습니다.

구현 방식은 **싱글톤 클래스 안에 private static 내부 클래스(Holder)를 두고**, 그 안에 싱글톤 인스턴스를 담는 정적 변수를 선언하는 것입니다. 코드 예시는 다음과 같습니다:

``` java
public class HolderSingleton {     
	// 내부 정적 클래스 - 싱글톤 인스턴스를 이 클래스에서 생성
	private HolderSingleton() {}          
	
	private static class SingletonHolder {         
		private static final HolderSingleton INSTANCE = new HolderSingleton();     
	}     
	
	public static HolderSingleton getInstance() {         
		return SingletonHolder.INSTANCE;     
	} 
}
```

`HolderSingleton` 클래스가 로딩될 때는 아직 `SingletonHolder`가 로딩되지 않습니다. 실제로 `getInstance()`를 호출할 때 처음으로 `SingletonHolder.INSTANCE`에 접근하게 되며, 그 순간 JVM이 `SingletonHolder` 클래스를 로딩하면서 **정적 초기화로 Singleton 인스턴스를 생성**합니다​. JVM의 클래스 초기화 과정은 한 번만 일어나고, **클래스 로딩과 정적 초기화는 스레드 안전하게 수행**되기 때문에 인스턴스 생성이 자동으로 동기화됩니다. 이렇게 함으로써 **동기화 없이도 Lazy 초기화**가 가능해집니다.

**장점:** 코드가 간결하면서도 명시적으로 synchronized를 사용하지 않고 **게으른 초기화**와 **스레드 안전성**을 모두 갖춥니다. 초기 접근 시 클래스 로딩 메커니즘을 이용하므로 성능도 우수합니다. 이 패턴은 구현의 용이성과 신뢰성 때문에 **가장 많이 사용되는 싱글톤 구현 패턴**으로 평가받습니다​.

**단점:** 특별한 단점은 거의 없으며, 이해만 된다면 실무에서 안심하고 쓸 수 있는 방식입니다. 다만 Java 외 다른 언어에서는 지원되지 않을 수 있는 기법이어서 범용적인 디자인 패턴 책에는 잘 언급되지 않을 뿐입니다.

## 내부 클래스 방식은 왜 스레드 안전한가?

위의 정적 내부 클래스(Holder) 방식이 어떻게 동기화 없이도 멀티스레드에 안전한지 좀 더 상세히 알아보겠습니다. 핵심은 **클래스 로딩과 초기화 시점의 스레드 안전성 보장**에 있습니다. 자바 언어 명세(JLS)에 따르면, 클래스의 초기화 때 JVM은 해당 클래스에 대한 **클래스 락(initialization lock)**을 취득하여 **초기화 과정을 직렬화**합니다. 즉, 어떤 클래스의 초기화 중에는 **동일 클래스에 대한 다른 스레드의 초기화 진행이 블로킹**되며, 한 스레드가 완료한 초기화의 **메모리 쓰기 결과를 모든 스레드가 볼 수 있도록 보장**됩니다.

정적 내부 클래스 홀더 패턴에서는 `SingletonHolder` 클래스의 정적 필드로 Singleton 인스턴스를 생성합니다. **최초로 `getInstance()`를 호출하는 스레드가 `SingletonHolder`를 로딩하면서 인스턴스를 생성**할 때, JVM이 해당 과정 전체를 한번에 수행하고 클래스 초기화 락을 사용하므로 다른 스레드들은 그 초기화가 끝날 때까지 `SingletonHolder`를 로딩하지 못합니다. 따라서 결과적으로 Singleton 인스턴스의 생성이 **한 번만 일어나고, 그 후로는 모든 스레드가 그 완전히 초기화된 인스턴스를 공유**하게 됩니다. 이러한 메커니즘 덕분에 별도의 동기화 없이도 내부 클래스 방식은 스레드 안전성을 확보합니다.

요약하면, **"클래스 로딩 지연 + JVM의 클래스 초기화 락"** 조합이 Holder 패턴의 안전성 비결입니다. 이는 『Java Concurrency in Practice』에서도 소개된 기법으로, JLS 12.4.1의 규정에 따라 **클래스는 참조될 때까지 초기화가 지연되고** JLS 12.4.2에 따라 **클래스 초기화 시 발생하는 정적 초기화는 동기화 되어 다른 스레드에 메모리 보장까지 이루어진다**고 설명되어 있습니다.

## volatile 키워드가 Double-Checked Locking에 필요한 이유

앞서 Double-Checked Locking 구현에서 `volatile` 키워드의 중요성을 언급했는데, 이를 조금 더 구체적으로 짚어보겠습니다. `volatile` 없이 이중 체크를 사용할 경우 발생할 수 있는 대표적인 문제는 **인스턴스 초기화 과정의 재정렬(reordering)**입니다. 자바에서 객체 생성 `instance = new Singleton();`은 JVM 내부적으로 여러 스텝으로 이루어질 수 있는데, 대략 (1) 메모리 할당 -> (2) 생성자 호출 -> (3) 변수에 참조 할당 순서로 진행됩니다. 그런데 JIT 컴파일러의 최적화나 CPU의 명령 재정렬에 의해 (2)와 (3)의 순서가 바뀌는 상황을 가정해봅시다. 즉, **생성자가 완전히 실행되기 전에 instance 참조가 먼저 할당**되어 버리면, 다른 스레드가 `instance` 필드를 읽어 null이 아니라고 판단하고 그 미완성 객체에 접근할 위험이 있습니다. 실제 멀티스레드 환경에서 이런 현상이 발생하면 심각한 오류를 유발할 수 있습니다 (예: 객체의 필드들이 아직 초기화되지 않은 상태로 보인다 등).

`volatile` 키워드는 이러한 문제를 해결해줍니다. `volatile`로 선언된 변수에 대한 쓰기는 다른 스레드에게 즉시 **가시성(visibility)**이 보장되며, 무엇보다 **명령어 재정렬을 방지**합니다​. 즉, `instance = new Singleton();`에서 instance에 참조를 할당하기 전에 객체 초기화가 완료되도록 순서가 보장됩니다​. 또한 volatile 변수에 대한 write는 그 이전까지의 메모리 쓰기 동작들과 사이에 **Happens-Before 관계**를 형성하므로, 어떤 스레드가 volatile `instance`에 기록한 Singleton 객체를 다른 스레드가 읽을 때는 그 객체의 생성자 내 초기화 내용까지 모두 메모리에서 볼 수 있게 됩니다​.

요약하면, **volatile을 사용함으로써 Double-Checked Locking 구현에서 발생할 수 있는 미묘한 메모리 불일치 문제와 재정렬 문제를 막아주는 것**입니다. 이러한 이유로 자바 5부터 메모리 모델이 개선된 이후에도 double-check 방식에는 여전히 volatile 사용이 필수로 권장됩니다​. 만약 volatile 없이 구현하면 특정 JVM이나 하드웨어 환경에서 간헐적인 오류가 나타날 수 있으므로 주의해야 합니다.

## 리플렉션을 통한 싱글톤 깨트리기

위에서 멀티스레드 상황에서 싱글톤 깨짐을 방지하는 법을 살펴보았지만, **자바의 리플렉션(reflection)**을 사용하면 싱글톤 패턴을 또 다른 방식으로 깨트릴 수 있습니다. 리플렉션을 이용하면 클래스의 private 생성자에도 접근하여 인스턴스를 강제로 생성할 수 있기 때문입니다. 예를 들어 아래와 같이 싱글톤 클래스의 생성자를 리플렉션으로 호출해보겠습니다:

``` java
Singleton inst1 = Singleton.getInstance(); // 리플렉션으로 private 생성자 호출 
Constructor<Singleton> cons = Singleton.class.getDeclaredConstructor(); cons.setAccessible(true); Singleton inst2 = cons.newInstance();  System.out.println(inst1 == inst2);  // false (서로 다른 인스턴스)
```

`inst1`은 정상적인 싱글톤 인스턴스이고, `inst2`는 리플렉션으로 만든 두 번째 인스턴스입니다. 위 결과에서 보듯이 두 객체는 다르며, **해시코드도 다르게 출력될 것입니다**. 이처럼 리플렉션을 사용하면 싱글톤 클래스의 private 생성자를 강제로 여러 번 호출함으로써 **싱글톤 규칙을 깨뜨리고 여러 객체를 생성**해낼 수 있습니다​. 특히 자바의 직렬화/역직렬화, 리플렉션 같은 메커니즘은 프레임워크(Spring, Hibernate 등) 내부에서도 자주 사용되므로, 생각지 못한 상황에서 싱글톤이 깨질 수 있다는 점을 주의해야 합니다​.

그렇다면 이러한 리플렉션 공격을 막을 방법은 없을까요? 완벽한 방어는 어렵지만, 몇 가지 대응책은 알려져 있습니다. 대표적인 방법은 **생성자 내부에 두 번째 인스턴스 생성을 막는 로직**을 넣는 것입니다. 예를 들어, 클래스 로딩 시 생성된 싱글톤 인스턴스를 가리키는 변수가 있다면, 생성자에서 그 변수가 이미 초기화되어 있는지 체크하여 **이미 인스턴스가 존재한다면 예외를 던지는** 식입니다​. 아래 예시는 Eager 싱글톤에 그러한 보호 로직을 추가한 것입니다:

``` java
public class ProtectedSingleton {     
	private static final ProtectedSingleton INSTANCE = new ProtectedSingleton();     
	private ProtectedSingleton() {         
		if (INSTANCE != null) {             
			throw new IllegalStateException("이미 인스턴스가 존재합니다!");         
		}     
	}     
	
	public static ProtectedSingleton getInstance() {         
		return INSTANCE;     
	} 
}
```

이렇게 하면 **리플렉션으로 생성자를 호출하더라도** 기존에 INSTANCE가 생성되어 있는 한 예외가 발생하여 추가 생성을 막을 수 있습니다. 다만 이 방법도 **완전하지는 않습니다**. 첫 번째 인스턴스가 아직 만들어지지 않은 시점에는 이런 체크가 소용없고, 리플렉션 호출 자체를 원천 봉쇄할 수는 없기 때문입니다. 자바에서는 `java.lang.reflect.AccessibleObject#setAccessible(true)`로 private 멤버 접근을 허용할 수 있으므로, 이러한 공격을 원천적으로 막기 위해선 Security Manager 등을 사용하여 리플렉션을 제한해야 하지만, 일반 애플리케이션에서는 현실적으로 적용하기 어렵습니다.

**궁극적인 해결책**으로는 **enum 싱글톤**을 사용하는 방법이 있습니다. enum을 사용하면 자바 언어 차원에서 리플렉션을 통한 생성자 호출을 제한하고 있어, 보다 간단하고 확실하게 싱글톤을 보장할 수 있습니다. 다음 절에서 enum을 이용한 싱글톤에 대해 살펴보겠습니다.

## enum을 이용한 싱글톤 구현

자바 5부터 추가된 **열거형(enum)**을 이용해서 싱글톤을 구현하는 방식은, Joshua Bloch(『Effective Java』의 저자)가 권장한 기법입니다. 자바 언어는 enum 타입에 특별한 규칙을 부여하여 **열거 값 각각을 딱 한 번만 인스턴스화하도록 보장**하기 때문에, 원소가 하나뿐인 enum을 만들면 자연스럽게 **싱글톤**이 됩니다​. 또한 enum으로 정의한 싱글톤은 **리플렉션을 통한 추가 인스턴스 생성을 방어**할 수 있고, **역직렬화 시에도 새로운 인스턴스가 생기지 않는** 장점이 있습니다​.

enum 싱글톤의 구현은 매우 간단합니다:

``` java
public enum EnumSingleton {     
	INSTANCE;  // 이 열거 상수가 유일한 인스턴스     
	
	// 필요한 메서드나 필드를 정의할 수 있음     
	public void doSomething() {         
		System.out.println("Singleton logic");     
	} 
}
```

사용할 때는 `EnumSingleton.INSTANCE`를 통해 인스턴스에 접근합니다. enum 특성상 **JVM이 클래스 로딩 시 해당 enum 상수들을 자동으로 생성**하며, 그 후에는 새로 생성할 수 없습니다. 따라서 리플렉션으로 enum의 생성자를 호출하려 해도 `java.lang.IllegalArgumentException` 등이 발생하여 실패하게 됩니다 (자바가 enum의 생성자를 특별 취급함).

**장점:** 구현이 가장 쉽고 코드가 명료합니다. `enum` 키워드 하나로 싱글톤의 인스턴스 생성과 관리가 모두 해결됩니다. 또한 앞서 언급한 리플렉션 공격이나 **직렬화에 의한 싱글톤 파괴도 JDK 수준에서 차단**됩니다​. 별도의 복잡한 코드 작성 없이 안전한 싱글톤을 얻을 수 있다는 점에서 **가장 단순하면서도 강력한 구현 방식**입니다. (실제로 Effective Java에서는 “가능하면 enum 싱글톤을 사용하라”고 권장합니다.)

**단점:** enum으로 구현한 싱글톤은 **클래스 상속이 불가능**하며, 다른 클래스의 서브클래스로 만들 수도 없습니다 (모든 enum은 `java.lang.Enum`를 상속). 또한 enum 타입 자체가 가지는 몇 가지 특성 때문에 싱글톤 용도로 쓸 때 **약간 어색함**이 있을 수 있습니다. 예를 들어, enum은 기본적으로 `values(), valueOf()` 등의 메서드나 직렬화된 형태 등 **여러 부가적인 특성**을 갖는데, 일반 싱글톤 객체에는 불필요한 것들입니다​. 그리고 열거형 상수는 **지연 초기화가 불가능**하다는 것도 단점으로 지적됩니다​. enum 싱글톤의 인스턴스는 해당 enum이 처음 사용될 때 생성되는데, 이는 사실상 Eager 초기화와 유사합니다. 보통은 처음 사용할 때 생성되므로 lazy하게 볼 수도 있지만, 좀 더 세밀하게 제어하거나 생성 시점을 통제하기는 어렵습니다.

**일반적인 기능 구현에 enum 싱글톤을 적극 사용하는 것이 적절한가?** 이 질문에 대해서는 개발자마다 견해가 조금 다릅니다. **장점 측면**에서 enum 싱글톤은 구현 오류의 여지가 없고 매우 단순하므로 분명 매력적입니다. **단점 측면**에서는, enum이라는 것이 본래 상수의 집합을 표현하기 위한 것인데 단일 객체 생성을 위해 쓰는 것이 약간 용도 혼재처럼 보일 수 있습니다. 또한 enum 싱글톤으로 만들면 아키텍처 변화(예를 들어 싱글톤이 아니게 수정하거나, 다른 클래스를 상속해야 하는 상황 등)에 유연하게 대응하기 어려울 수 있습니다. 이러한 이유로 일부 개발자들은 **굳이 열거형을 남용하기보다는** 앞서 소개한 **정적 내부 클래스 방식을 더 선호**하기도 합니다​. 실제 한 블로그의 비교에서도 “enum 방식은 직렬화/리플렉션 문제를 자동으로 해결해주지만, 불필요한 Enum 메서드들이 노출되고 설계상 유연성이 떨어져 나는 Holder 방식을 가장 선호한다”는 견해가 있었습니다.

결론적으로, **enum 싱글톤은 가장 쉽고 안전한 구현**임에는 틀림없으므로, 해당 클래스가 열거형으로 표현되는 것이 어색하지 않고, 향후 확장 가능성 등이 크게 문제되지 않는다면 사용하는 게 좋습니다. 특히 **직렬화 안정성이나 리플렉션 공격 방지가 중요**한 경우 enum 싱글톤이 유용합니다. 하지만 프로젝트에서 이미 DI 프레임워크(Spring 등)를 사용 중이라면 굳이 enum 싱글톤을 쓰기보다는 프레임워크의 빈을 싱글톤 범위로 활용하는 편이 더 일반적입니다. 다음으로 Spring에서의 싱글톤 빈 관리에 대해 알아보겠습니다.

## 스프링 레거시 환경에서의 싱글톤 빈

엔터프라이즈 자바 개발에서는 직접 싱글톤을 구현하기보다는 **스프링(Spring)과 같은 DI 프레임워크의 빈 스코프**를 이용해 싱글톤을 많이 관리합니다. 스프링에서는 특별한 설정이 없는 한 **모든 스프링 빈(bean)의 기본 스코프가 싱글톤**입니다. 즉, XML 설정으로 빈을 정의하거나 클래스에 `@Controller`, `@Service`, `@Repository` 등의 어노테이션을 붙여 컴포넌트 스캔으로 빈을 등록하면, Spring IoC 컨테이너는 그 빈 정의당 한 개의 객체만 생성해서 관리합니다​. 모든 요청은 컨테이너에 캐싱된 같은 인스턴스를 돌려받게 되므로, 결과적으로 **스프링 빈은 기본적으로 싱글톤으로 동작**합니다​.

예를 들어, XML로 다음과 같이 빈을 설정했다고 가정하겠습니다:

``` xml
<bean id="myService" class="com.example.MyService" scope="singleton"/>
```

(사실 `scope="singleton"`은 명시하지 않아도 기본값이 singleton입니다.) 이 빈을 애플리케이션에서 두 번 가져와 비교해보면:

``` java
ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); 
Object s1 = ctx.getBean("myService"); 
Object s2 = ctx.getBean("myService"); 
System.out.println(s1 == s2);  // true, 같은 인스턴스
```

출력은 true가 나오며, **동일한 빈 id로 요청한 객체는 항상 같은 인스턴스를 반환**한다는 것을 확인할 수 있습니다. Spring 공식 문서에도 “**특정 bean id에 해당하는 요청은 모두 그 하나의 공용 인스턴스를 돌려준다**”고 명시되어 있습니다​.

스프링에서 어노테이션 기반으로 빈을 등록하는 경우도 마찬가지입니다. 예를 들어 `@Service`나 `@Controller`를 붙인 클래스는 특별히 범위를 지정하지 않는 한 singleton 스코프로 컨테이너에 올라갑니다. 따라서 여러 컨트롤러가 같은 서비스를 `@Autowired` 받으면, 모두 **동일한 서비스 인스턴스**를 주입받게 됩니다. 마찬가지로 한 컨트롤러가 여러 번 사용되더라도 컨트롤러 객체 자체는 하나만 생성되어 재사용됩니다. (Spring MVC에서 **Controller는 기본 singleton**이므로 다수의 요청을 병렬로 처리할 때 내부에 상태를 유지하면 안 되고, 지역 변수나 쓰레드 로컬 등을 사용해야 하는 것도 이 때문입니다.)

다만 유의해야 할 점은, 스프링의 싱글톤 스코프는 **애플리케이션(또는 스프링 컨테이너) 범위 내에서 싱글톤**이라는 뜻입니다. 자바의 Singleton 패턴이 “JVM 내에서 클래스당 하나”를 의미한다면, Spring의 singleton 스코프는 “컨테이너당 bean 정의당 하나”를 의미합니다. 예컨대 같은 클래스로 두 개의 서로 다른 빈을 정의하면 (id나 이름이 다르면) 당연히 별개 인스턴스 두 개가 생깁니다​. 또한 동일 클래스라도 여러 Spring 컨테이너가 있으면 컨테이너별로 인스턴스가 생길 수 있습니다. 하지만 일반적으로 하나의 애플리케이션에서는 한 개의 컨테이너가 각 클래스당 하나의 빈을 만들므로, Singleton 패턴과 큰 차이 없이 운용할 수 있습니다.

**정리하면:** 스프링 레거시든 부트든, 특별한 설정을 하지 않으면 우리가 정의하는 **빈들은 모두 싱글톤으로 관리**됩니다. 따라서 별도로 디자인 패턴의 Singleton을 구현하지 않아도 필요한 컴포넌트들을 싱글톤처럼 활용할 수 있습니다. Spring을 사용하는 프로젝트에서는 직접 Singleton 클래스를 만드는 일은 드물고, 대신 이 빈 싱글톤에 필요한 의존성을 주입 받아 사용하는 식으로 구조를 잡습니다.

## 싱글톤 패턴의 장점과 단점

싱글톤 패턴의 **장점**과 **단점**을 종합적으로 정리하면 다음과 같습니다:

- **장점:**
    
    - **오직 하나의 인스턴스만 존재**하므로 메모리 낭비를 방지합니다. 동일한 객체를 여러 번 생성하는 일이 없어서 자원 절약에 도움이 됩니다.
        
    - 인스턴스가 전역적으로 공유되기 때문에 **어디서든 손쉽게 접근**할 수 있습니다. (`ClassName.getInstance()`를 통해 어떤 클래스에서든 같은 객체를 얻어 사용 가능)
        
    - 초기화가 한 번만 이루어지므로 **객체 생성 비용이 큰 경우 효율적**입니다. (예: DB 연결 풀 같이 설정에 비용이 큰 자원)
        
    - **상태의 일관성**을 유지하기 쉽습니다. 모든 요청이 동일 객체를 참조하므로, 한 곳에서 상태가 변경되면 즉시 전역에 반영됩니다.
        
- **단점:**
    
    - **전역 상태를 갖는 객체**이므로 잘못 사용하면 객체 지향 설계를 망칠 수 있습니다. 클래스 간 결합도가 높아지고, 숨겨진 의존성이 생겨 코드가 난해해질 수 있습니다. 일각에서는 싱글톤을 **“안티패턴”**으로 부르기도 합니다.
        
    - **테스트하기 어려워집니다.** 의존성을 주입받는 대신 `Singleton.getInstance()`로 가져오는 구조는 **목(mock) 객체로 대체하기 어렵고**, 테스트 간 격리가 힘듭니다. (싱글톤 내부 상태가 누적되어 테스트 간 간섭을 줄 수도 있습니다.)
        
    - 멀티스레드 환경에서 신중히 구현하지 않으면 쉽게 **버그**가 발생합니다. (예: 동기화 누락 시 인스턴스가 두 개 생기거나, 잘못된 double-check 구현으로 인한 데이터 불일치 등)
        
    - **유연성이 떨어집니다.** 싱글톤으로 설계된 클래스는 상속을 허용하기 어렵고(생성자가 private), 다른 형태로 인스턴스 관리 방식 변경이 어렵습니다. 나중에 인스턴스가 둘 이상 필요하게 설계를 바꾸기도 까다롭습니다.
        
    - 자바 환경에서는 **클래스 로더별로 별도의 인스턴스**가 생길 수 있어 100% 전역은 아닙니다. (예: 어플리케이션 서버에서 WAR마다 동일 Singleton 클래스를 로드하면 각각 인스턴스가 생김)
        
    - 리플렉션이나 직렬화 등을 통해 **싱글톤 규약이 깨질 수 있는 취약성**이 존재합니다. (enum 싱글톤으로 보완 가능하지만 일반적인 구현의 경우)
        

이처럼 싱글톤 패턴은 **간편함과 효율**의 장점을 갖지만, **남용하면 문제**가 될 수 있습니다. 규모가 큰 프로젝트에서는 싱글톤 남용을 경계하고, 보통 객체 생명주기를 프레임워크나 컨테이너에 맡겨 관리하는 추세입니다.

## 싱글톤 패턴과 스프링 빈 관리 방식 비교

마지막으로, 전통적인 싱글톤 패턴과 스프링의 빈 관리 방식의 차이를 간단히 비교해보겠습니다:

- **인스턴스 생성 주체:** 싱글톤 패턴에서는 클래스 자신이 정적 메서드를 통해 **직접 인스턴스를 관리**합니다. 반면 스프링에서는 **컨테이너(IoC)**가 객체를 생성하고 관리하며, 사용자는 이를 주입(Injection)받거나 `getBean`으로 얻습니다. 즉, 싱글톤 패턴은 **능동적 객체 생성(스스로 생성)**이고, 스프링 빈은 **수동적 객체 생성(컨테이너에 의해 생성)**입니다.
    
- **글로벌 접근 vs DI:** 싱글톤 패턴 객체는 `ClassName.getInstance()` 처럼 **글로벌 접근점**이 있어 어디서든 호출 가능합니다. 스프링 빈은 주로 의존성 주입을 통해 전달되므로 **명시적인 요청 없이도 필요한 곳에 주입**됩니다. 이는 코드의 **결합도를 낮추고 테스트 용이성**을 높여줍니다. (예: 싱글톤 패턴을 쓰면 테스트 시 global instance를 가로채기 어렵지만, 스프링 빈은 인터페이스 분리와 주입으로 목 객체 대체 등이 쉬움)
    
- **인스턴스 수와 범위:** 전통 싱글톤은 원칙적으로 **JVM 내에 클래스당 하나**의 인스턴스를 의미합니다. 반면 스프링의 싱글톤 빈은 **컨테이너당 빈 정의당 하나**입니다. 따라서 같은 클래스라도 여러 bean으로 정의하면 여러 개 생성될 수 있고, 여러 컨테이너가 있으면 각각 인스턴스를 가질 수 있습니다​. 한편 스프링은 singleton 외에도 prototype, request, session 등의 다양한 스코프를 지원하여 필요에 따라 다수 인스턴스 사용도 유연하게 조절 가능합니다.
    
- **초기화 시점:** 싱글톤 패턴은 lazy로 구현할지 eager로 할지 개발자가 선택합니다. 스프링은 기본적으로 컨테이너가 시작될 때 **모든 싱글톤 빈을 미리 생성(eager)**합니다. (단, `@Lazy` 어노테이션이나 `<bean lazy-init="true">` 설정으로 지연 로딩을 할 수도 있습니다.) 따라서 싱글톤 패턴은 **지연 초기화 여부를 수동으로 관리**하지만, 스프링은 기본 eager이므로 **초기 부하가 있을 수 있지만 의존성 오류를 빨리 잡는 장점**도 있습니다.
    
- **라이프사이클 관리:** 전통 싱글톤은 애플리케이션 종료 시까지 계속 남아있고 별도 제거 과정이 없습니다. 스프링에서는 컨테이너가 빈의 **생명주기**를 관리하며, 필요시 `@PreDestroy` 등을 통해 종료 시 정리 작업을 할 수 있습니다. 또한 컨테이너 종료와 함께 빈도 가비지 컬렉션 대상이 됩니다.
    
- **사용 패턴:** 싱글톤 패턴은 주로 **Utility 성격**이나 **공용 서비스 객체**에 적용되며, 직접 코드에서 제어합니다. 스프링 싱글톤 빈은 **계층 구조상의 서비스, 리포지토리, 컨트롤러 등 광범위하게 적용**되고, 프레임워크에 의해 관리되므로 개발자는 객체 생성/소멸보다는 비즈니스 로직 작성에 집중할 수 있습니다.
    

결국 **스프링 빈**은 싱글톤 패턴의 장점을 컨테이너 수준에서 구현한 것이라 볼 수 있습니다. 다만 코드 레벨에서의 구현이 아니므로 테스트나 구조 측면에서 더 유연하고, 디자인 패턴으로서의 싱글톤이 가진 여러 제약을 완화해줍니다. 그래서 **스프링을 사용하는 환경에서는 굳이 직접 싱글톤 클래스를 만들 필요가 줄어들었고**, 대부분의 싱글톤 역할을 스프링이 대신하고 있습니다.

## 예상 질문과 답변 (Q&A)

마지막으로, 싱글톤 패턴에 대해 스터디 발표를 할 때 나올 법한 질문들과 그에 대한 답변을 정리해 보겠습니다:

1. **Q:** 리플렉션으로 싱글톤을 깨트릴 수 있다고 했는데, **어떻게 방지할 수 있을까요?**  
    **A:** 완벽하게 막기는 어렵지만, 방어적 코딩으로 어느 정도 예방할 수 있습니다. 한 가지 방법은 **생성자에서 두 번째 객체 생성을 감지해 예외를 던지는 것**입니다. 즉, 클래스의 static 인스턴스가 이미 초기화되었다면 private 생성자에서 `throw`를 하는 것이죠. 이렇게 하면 리플렉션으로 생성자를 호출해도 기존 인스턴스가 있을 경우 예외가 발생해 추가 생성이 안 됩니다. 그러나 애초에 첫 번째 인스턴스가 없을 때는 막기 어렵고, 리플렉션 자체를 원천 봉쇄할 순 없으므로 완전하지는 않습니다. **보다 확실한 방법은 enum 싱글톤을 사용하는 것**입니다. enum은 자바 언어상 리플렉션으로 새로운 인스턴스를 만들 수 없게 되어 있어 안전합니다.
    
2. **Q:** **직렬화(Serialization)를 통해서도** 싱글톤이 깨질 수 있나요? 대처법은?  
    **A:** 네, 직렬화/역직렬화로 싱글톤 객체를 파일 등에 저장했다 복원하면 **새로운 인스턴스**가 생성될 수 있습니다​. 이런 상황을 막으려면 `readResolve()` 메서드를 활용해야 합니다. 싱글톤 클래스에 `protected Object readResolve()`를 구현하여 **역직렬화 시 항상 기존의 싱글톤 인스턴스를 반환**하도록 하면 됩니다​. 이렇게 하면 직렬화된 데이터를 읽어도 결과적으로는 기존 하나의 인스턴스만 사용하게 되어 싱글톤 규칙이 지켜집니다. enum 싱글톤의 경우 Java가 내부적으로 이 처리를 해주기 때문에 별도 대응이 필요 없습니다.
    
3. **Q:** **static 클래스/메서드**로만 구성하면 굳이 싱글톤 안 써도 되는 것 아닌가요? 둘의 차이가 뭔가요?  
    **A:** static 메서드만 있는 클래스(예: `Math` 클래스의 메서드들)와 싱글톤은 겉보기엔 유사하게 쓸 수 있지만, 차이가 있습니다. **싱글톤은 인스턴스 객체**이기 때문에 인터페이스 구현이나 다형성 활용, 의존성 주입 등이 가능합니다. 반면 static 방식은 인터페이스 구현이나 런타임 객체 교체가 불가능해서 유연성이 떨어집니다. 또한 **상태를 유지해야 하는 경우** static 전역 변수로 관리하면 사실상 싱글톤과 다름없는데, 이 경우 차라리 싱글톤 패턴으로 만드는 것이 응집된 설계에 도움이 됩니다. 요약하면, **간단한 유틸성 기능**은 static으로 충분하지만, **상태를 갖거나 확장 가능성이 있는 구성요소**는 싱글톤 패턴이 더 적합합니다. (예를 들어 로깅 객체를 static으로만 두면 인터페이스 기반 교체가 어렵지만, 싱글톤 인스턴스로 두면 인터페이스를 구현하여 다른 구현체로 교체하거나 목킹하기가 상대적으로 수월합니다.)
    
4. **Q:** 스프링에서 서비스나 컨트롤러 빈들은 싱글톤이라고 했는데, **여러 스레드가 동시에 이 빈을 사용하면 문제되지 않나요?**  
    **A:** 일반적으로 문제가 없도록 설계합니다. 스프링의 싱글톤 빈 (예: `@Service` 빈)은 **상태를 저장하지 않는 무상태(stateless) 객체**로 설계하는 것이 원칙입니다. 여러 요청(스레드)이 동시에 같은 서비스 객체의 메서드를 호출해도, 그 서비스 객체가 내부에 요청별 데이터를 필드로 갖고 있지 않으면 스레드간 간섭이 없습니다. 만약 일부 상태가 필요하면 요청 범위의 지역 변수나 쓰레드 로컬, DB같은 외부 저장소를 사용하고, 빈 자체는 공유 상태를 두지 않도록 합니다. 컨트롤러도 마찬가지로, 요청마다 지역변수를 통해 처리하고 **인스턴스 필드를 공동으로 쓰지 않도록** 해야 합니다. 이렇게 코드를 짠다면 싱글톤으로 여러 스레드가 빈을 쓰더라도 논리적으로 안전합니다. 반대로 **빈이 내부에 가변 상태를 가지고 있다면 thread-safe하게 동기화하거나, 필요하면 scope을 prototype으로 바꾸는** 등 대책이 필요합니다.
    
5. **Q:** **동기화된 싱글톤(`synchronized getInstance`)의 성능이 정말 그렇게 나쁜가요?** 지금 시대에도 Double-Checked Locking이 필요할까요?  
    **A:** 과거에는 synchronized 자체의 성능 부담을 많이 걱정했지만, **현재 JVM에서는 경쟁이 없는 경우 거의 비용이 매우 적게** 최적화되었습니다. 즉, 싱글톤처럼 초기화 후에는 경쟁이 없거나 아주 짧은 경우라면 단순 동기화도 큰 문제는 아닌 상황이 많습니다. Double-Checked Locking은 초기화 이후의 불필요한 락 획득을 피하는 최적화 기법인데, 코드가 복잡해지는 데 비해 실익이 크지 않을 수 있습니다. 그래서 **Joshua Bloch 등도 “굳이 복잡하게 하지 말고 필요하면 그냥 synchronized를 쓰라”고 조언**하곤 합니다. 다만 정말로 `getInstance()`를 **매우 빈번히 호출**해서 이 오버헤드가 누적되는 상황이라면 Double-Checked Locking이나 내부 클래스 홀더 방법을 고려해볼 가치가 있습니다. 요약하자면: “성능 문제가 없다면 구현이 단순한 방법이 최선”입니다.
    
6. **Q:** **스프링을 쓰는 프로젝트에서**도 직접 싱글톤 패턴 클래스를 구현해서 사용할 때가 있나요?  
    **A:** 특별한 경우가 아니면 드뭅니다. 스프링이 제공하는 싱글톤 빈으로 대부분 충분하기 때문입니다. 예를 들어 어떤 관리자 클래스나 서비스도 스프링 빈으로 등록하면 자동으로 싱글톤으로 관리되므로, 굳이 직접 싱글톤 패턴을 구현할 필요가 없습니다. 오히려 Spring 컨테이너가 라이프사이클도 관리해주고 의존성 주입도 해결해주기 때문에 그 편이 더 편리합니다. 따라서 **스프링 기반 애플리케이션에서는 싱글톤 패턴 자체를 직접 구현하는 일은 거의 없고**, 프레임워크에 맡기는 게 일반적입니다. 다만 Spring과 무관하게 동작해야 하는 **유틸리티성 클래스**나, 또는 **Enum 싱글톤처럼 명시적으로 한 개만 존재함을 보장하고 싶은 경우** 등에 한해 싱글톤 패턴을 구현하는 경우는 있습니다. (예를 들어 Java `Runtime`처럼 어딘가 Spring 컨테이너와 무관하게 전역으로 접근해야 하는 객체 등) 하지만 이러한 경우도 가능하면 Spring 빈으로 만드는 게 추세입니다.
    
7. **Q:** Enum 싱글톤에 단점으로 나온 **“유연성이 떨어진다”**는게 무슨 의미인가요?  
    **A:** Enum 싱글톤은 편리하지만, Enum 자체의 제약 때문에 **일반 클래스보다 활용에 제한**이 있습니다. 일단 enum은 다른 클래스를 상속할 수 없고 (항상 `java.lang.Enum` 상속), 또 하나의 enum 타입은 일종의 상수 집합이기 때문에 그 외에 추가 필드를 갖거나 하는 건 가능하지만 개념적으로 **역할이 제한**됩니다. 예컨대 싱글톤 클래스가 나중에 어떤 인터페이스의 구현체 여러 개 중 하나로 바뀌어야 한다면, enum 싱글톤으로 만들어두면 변경이 어렵습니다. 그리고 enum을 싱글톤으로 쓸 때, 자동으로 생기는 `values()` 같은 static 메서드나 직렬화 형태 등은 사실상 필요없는 부가물인데, 그런 것들이 생기는 것도 싫을 수 있습니다​. 이런 이유로 어떤 사람들은 Enum 싱글톤이 “우아하지 못하다”고 느낄 수 있습니다. 그러나 이러한 단점들도 **싱글톤이 꼭 필요하면서 불변에 가까운 경우에는 크게 문제되지 않을 수 있습니다**. 결국 선택은 상황과 팀의 컨벤션에 따릅니다.